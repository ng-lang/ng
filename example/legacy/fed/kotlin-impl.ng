--- for lexers

type List<t> = | cons Cons(t, List<t>) | cons Nil

type array<t, arity: Int>

sig get :: array<t, n> -> Int -> Maybe<t>

val shit: array<Int, 5> {1, 2, 3, 4, 5}

shit.get(3) |> print

val list: Cons(1, Cons(2, Cons(3, Cons(4, Cons(5)))))

sig length :: List<t> -> Int
fun length l = case l
   | Cons(x, xs) => length(xs) + 1
   | Nil => 0

type Fact<x: Int> = {
    value: x * Fact<x-1>.value
}

type Fact<0> = {value: 1}

sig fact :: Int -> Int
fun fact n = Fact<n>::value

type array_of_int = array<Int>

type! array_of_char = array<Char>

type ref<t> = ref t

sig (~>) :: ref<t> -> t

val shit2 = ref shit

shit2.~>.get(3)

--- for parsers

type List<t> = | cons Cons(t, List<t>) | cons Nil

type array_of_int = array<Int>

sig get :: t, n => array<t, n> -> Int -> Maybe<t>

sig length :: t => List<t> -> Int

sig fact :: Int -> Int

fun main = shit.get(3) |> print

fun lucky a = if a >= 0 then 1 else 2

fun fact x = if x = 0 then 1 else x * fact(x - 1)